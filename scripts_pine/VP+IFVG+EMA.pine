//@version=5
indicator("Volume Profile + IFVG + EMAs [Combined]", "VP + IFVG + EMAs", overlay = true, max_boxes_count = 500, max_lines_count = 500, max_labels_count = 500, max_bars_back = 5000)

//---------------------------------------------------------------------------------------------------------------------}
// PESTA√ëA DE DOCUMENTACI√ìN
//---------------------------------------------------------------------------------------------------------------------{
docGR = 'üìö DOCUMENTACI√ìN'

docText = '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n' +
          'üìä ESTRATEGIA VOLUME PROFILE + IFVG + EMAs\n' +
          '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n' +
          'üéØ RESUMEN DE LA ESTRATEGIA:\n' +
          'Esta estrategia combina 3 indicadores poderosos:\n' +
          '‚Ä¢ IFVG (Huecos de Inversi√≥n de Valor Justo)\n' +
          '‚Ä¢ Perfil de Volumen (VP)\n' +
          '‚Ä¢ Medias M√≥viles Exponenciales (EMAs)\n\n' +
          '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n' +
          'üî∫ SE√ëALES LONG (COMPRA):\n' +
          '1. Tri√°ngulo IFVG ‚ñ≤: Precio re-entra en FVG bajista\n' +
          '2. Cruce EMA ‚¨Ü: EMA r√°pida cruza sobre EMA lenta\n' +
          '3. VP Demanda üü¶: Precio en zona de demanda (azul)\n' +
          '4. Toque VAL üìâ: Precio toca Value Area Low\n' +
          '5. Cruce POC ‚ûï: Precio cruza por encima del POC\n\n' +
          'üîª SE√ëALES SHORT (VENTA):\n' +
          '1. Tri√°ngulo IFVG ‚ñº: Precio re-entra en FVG alcista\n' +
          '2. Cruce EMA ‚¨á: EMA r√°pida cruza bajo EMA lenta\n' +
          '3. VP Oferta üü•: Precio en zona de oferta (rojo)\n' +
          '4. Toque VAH üìà: Precio toca Value Area High\n' +
          '5. Cruce POC ‚ûñ: Precio cruza por debajo del POC\n\n' +
          '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n' +
          'üí° MEJORES PR√ÅCTICAS:\n' +
          '‚Ä¢ Usar m√∫ltiples se√±ales para confirmaci√≥n\n' +
          '‚Ä¢ Verificar aumento de volumen en entrada\n' +
          '‚Ä¢ Colocar stop loss m√°s all√° de la zona FVG\n' +
          '‚Ä¢ Tomar ganancia en POC o extremos de VA\n' +
          '‚Ä¢ Operar a favor de la tendencia (seguir EMAs)\n\n' +
          '‚ö†Ô∏è GESTI√ìN DE RIESGO:\n' +
          '‚Ä¢ Nunca arriesgar m√°s del 2% por operaci√≥n\n' +
          '‚Ä¢ Usar tama√±o de posici√≥n apropiado\n' +
          '‚Ä¢ Siempre establecer √≥rdenes stop loss\n' +
          '‚Ä¢ Monitorear condiciones del mercado\n\n' +
          '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n' +
          'Documentaci√≥n completa: Ver comentarios del script\n' +
          '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê'

_ = input.text_area(docText, "Documentaci√≥n de la Estrategia", group = docGR, 
    tooltip = "Gu√≠a completa sobre c√≥mo funciona esta estrategia y c√≥mo usar las se√±ales")

//---------------------------------------------------------------------------------------------------------------------}
// CONFIGURACI√ìN DE SE√ëALES ADICIONALES
//---------------------------------------------------------------------------------------------------------------------{
sigGR = 'üéØ Se√±ales de Entrada Adicionales'

// Se√±ales de Cruce de EMAs
enableEMACross = input.bool(true, "Se√±ales de Cruce de EMA", inline = "ema1", group = sigGR,
    tooltip = "Mostrar tri√°ngulos cuando la EMA r√°pida cruza la EMA lenta")
emaCrossFast = input.int(20, "EMA R√°pida", inline = "ema1", group = sigGR)
emaCrossSlow = input.int(50, "EMA Lenta", inline = "ema1", group = sigGR)
emaSignalSize = input.string("Small", "Tama√±o de Se√±al", options = ["Tiny", "Small", "Normal"], inline = "ema2", group = sigGR)

// Se√±ales de Niveles del Perfil de Volumen
enableVPSignals = input.bool(true, "Se√±ales de Perfil de Volumen", inline = "vp1", group = sigGR,
    tooltip = "Mostrar tri√°ngulos en toques de POC, VAH y VAL")
vpSignalPOC = input.bool(true, "Toque POC", inline = "vp2", group = sigGR)
vpSignalVAH = input.bool(true, "Toque VAH", inline = "vp2", group = sigGR)
vpSignalVAL = input.bool(true, "Toque VAL", inline = "vp2", group = sigGR)

// Se√±ales de Zonas de Oferta/Demanda
enableSDSignals = input.bool(true, "Se√±ales de Oferta/Demanda", inline = "sd1", group = sigGR,
    tooltip = "Mostrar tri√°ngulos cuando el precio entra en zonas de O/D")
sdSignalStrength = input.string("Strong Only", "Filtro de Se√±al", options = ["All", "Strong Only"], inline = "sd1", group = sigGR)

// Se√±ales de Picos de Volumen
enableVolSignals = input.bool(false, "Se√±ales de Picos de Volumen", inline = "vol1", group = sigGR,
    tooltip = "Mostrar tri√°ngulos en velas con volumen alto")
volSpikeMulti = input.float(2.0, "Multiplicador de Volumen", minval = 1.0, step = 0.5, inline = "vol1", group = sigGR)

// Colores de Se√±ales
signalBullColor = input.color(color.new(#00ff00, 0), "Se√±al Alcista", inline = "col1", group = sigGR)
signalBearColor = input.color(color.new(#ff0000, 0), "Se√±al Bajista", inline = "col1", group = sigGR)

//---------------------------------------------------------------------------------------------------------------------}
// IFVG SETTINGS
//---------------------------------------------------------------------------------------------------------------------{
disp_num = input.int(5, maxval = 100, minval = 1, title = "Show Last", tooltip = "Specifies the amount of most recent inversion FVG to display in Bullish/Bearish pairs, starting at the current and looking back.")
signal_pref = input.string("Close", title = "Signal Preference", options = ["Close","Wick"], tooltip = "Choose to send signals based on Wicks or Close Price.")
wt = signal_pref == "Wick"
atr_multi = input.float(0.25, step = 0.25,minval = 0,  title = "ATR Multiplier", tooltip = "Filters FVGs based on ATR Width, Only displays Inversions that are Greater-Than the ATR*Multiplier.")

// IFVG Colors
green = input.color(color.new(#089981, 80), title = "Bull Color", group = "IFVG Colors")
red = input.color(color.new(#f23645, 80), title = "Bear Color", group = "IFVG Colors")
gray = input.color(#787b86, title = "Midline Color", group = "IFVG Colors")
invis = color.rgb(0,0,0,100)

//---------------------------------------------------------------------------------------------------------------------}
// VOLUME PROFILE SETTINGS
//---------------------------------------------------------------------------------------------------------------------{
disp = display.all - display.status_line

vpGR = 'Volume & Sentiment Profile'

vpTP   = 'displays total trading activity (both buying and selling trading activity) over a specified time period at specific price levels\n\n' +
          'row lengths, indicates the amount of the traded activity at specific price levels\n\n' +
          ' - high traded zones - usually represents consolidation zones (value areas)\n' +
          ' - low traded zones - usually represents supply & demand or liquidity zones'

vpSH = input.bool(true, 'Volume Profile', group = vpGR, tooltip = vpTP)

vpUC = input.color(color.new(#5d606b, 50), '‚ÄÉ‚ÄÉUp Volume‚ÄÉ', inline = 'VP', group = vpGR)
vpDC = input.color(color.new(#d1d4dc, 50), 'Down Volume‚ÄÉ', inline = 'VP', group = vpGR)

vaUC = input.color(color.new(#2962ff, 30), '‚ÄÉ‚ÄÉValue Area Up', inline = 'VA', group = vpGR)
vaDC = input.color(color.new(#fbc02d, 30), 'Value Area Down', inline = 'VA', group = vpGR)

spTP   = 'displays the sentiment, the dominat party over a specified time period at the specific price levels\n\n' +
          ' - bullish node rows : buying trading activity is higher\n'  +
          ' - barish node rows : selling trading activity is higher\n\n' +
          'row lengths, indicates the strength of the buyers/sellers at the specific price levels'

spSH = input.bool(true, 'Sentiment Profile', group = vpGR, tooltip = spTP)
spUC = input.color(color.new(#26a69a, 30), '‚ÄÉ‚ÄÉBullish', inline = 'BB', group = vpGR)
spDC = input.color(color.new(#ef5350, 30), 'Bearish', inline = 'BB', group = vpGR)

sdTT = 'Defines the relationship between the price of a given asset and the willingness of traders to either buy or sell it'
sdSH = input.bool(true, 'Supply & Demand Zones', group = vpGR, tooltip = sdTT)
sdTH = input.int(15, '‚ÄÉ‚ÄÉSupply & Demand Threshold %', minval = 0, maxval = 41, group = vpGR, display = disp) / 100
sdSC = input.color(color.new(#ec1313, 80), '‚ÄÉ‚ÄÉSupply Zones', inline = 'SD', group = vpGR)
sdDC = input.color(color.new(#0094FF, 80), 'Demand Zones', inline = 'SD', group = vpGR)

pcSH = input.string('Developing POC', 'Point of Control', options = ['Developing POC', 'Last (Line)', 'None'], inline = 'POC', group = vpGR, display = disp)
pocC = input.color(#f44336, '', inline = 'POC', group = vpGR)
pocW = input.int(2, '', minval = 1, inline = 'POC', group = vpGR, display = disp)

vpVA = input.float(68, 'Value Area (%)', minval = 0, maxval = 100, group = vpGR, display = disp) / 100

vahS = input.bool(true, 'Value Area High (VAH)', inline = 'VAH', group = vpGR)
vahC = input.color(#2962ff, '', inline = 'VAH', group = vpGR)
vahW = input.int(1, '', minval = 1, inline = 'VAH', group = vpGR, display = disp)

vlSH = input.bool(true, 'Value Area Low (VAL)', inline = 'VAL', group = vpGR)
valC = input.color(#2962ff, '', inline = 'VAL', group = vpGR)
valW = input.int(1, '', minval = 1, inline = 'VAL', group = vpGR, display = disp)

spPT = 'polarity methods is a measure used to divide the total volume into either up volume (trades that moved the price up) or ' +
         'down volume (trades that moved the price down), simply said conditions used to calculate up/down volume\n\n' +
         '* bar polarity\n   up     => if close > open\n   down => if close <= open\n\n' +
         '* bar buying/selling pressure\n   up     => if (close - low) > (high - close)\n   down => if (close - low) <= (high - close)'
spP1 = 'Bar Polarity'
spP2 = 'Bar Buying/Selling Pressure'
vpPT = input.string(spP1, 'Profile Polarity Method', options = [spP1, spP2], group = vpGR, tooltip = spPT, display = disp)
vsPT = vpPT == spP1

vpLR = input.string('Fixed Range', 'Profile Lookback Range', options = ['Fixed Range', 'Visible Range'], group = vpGR, display = disp)
vpRL = vpLR == 'Visible Range'
vpLT = 'applicable when \'Lookback Range\' is selected as \'Fixed Range\''
vpLN = input.int(360, 'Lookback Length / Fixed Range', minval = 10, maxval = 5000, step = 10, group = vpGR, tooltip = vpLT, display = disp)
vpLN:= last_bar_index < vpLN ? last_bar_index : vpLN - 1

vpST = input.bool(true, 'Profile Stats', inline = 'STT', group = vpGR, display = disp)
ppLS = input.string('Small', "", options = ['Tiny', 'Small', 'Normal'], inline = 'STT', group = vpGR, display = disp)
lcDB = input.string('Top Right', '', options = ['Top Right', 'Middle Right', 'Bottom Left'], inline = 'STT', group = vpGR, display = disp)

vpLV = input.bool(true, 'Profile Price Levels', inline = 'BBe', group = vpGR)
rpLS = input.string('Small', "", options=['Tiny', 'Small', 'Normal'], inline = 'BBe', group = vpGR, display = disp)

vpPL = input.string('Right', 'Profile Placement', options = ['Right', 'Left'], group = vpGR, display = disp)
vpRT = vpPL == 'Right'
vpNR = input.int(100, 'Profile Number of Rows' , minval = 10, maxval = 150 , step = 10, group = vpGR, display = disp)
vpWD = input.float(31, 'Profile Width', minval = 0, maxval = 250, group = vpGR, display = disp) / 100
vpHO = input.int(13, 'Profile Horizontal Offset', maxval = 50, group = vpGR, display = disp)

vaBG = input.bool(false, 'Value Area Background‚ÄÉ‚ÄÉ', inline = 'vBG', group = vpGR)
vBGC = input.color(color.new(#2962ff, 89), '', inline = 'vBG', group = vpGR)

vpBG = input.bool(false, 'Profile Range Background‚ÄÉ', inline = 'pBG', group = vpGR)
bgC  = input.color(color.new(#2962ff, 95), '', inline = 'pBG', group = vpGR)

vhGR  = 'Volume Histogram'

vhTT = 'The Volume indicator is used to measure how much of a given financial asset has traded in each specific candle'
vhSH = input.bool(true, 'Volume Histogram', group = vhGR, tooltip = vhTT)
vmaS = input.bool(true, 'Volume MA, ‚Äá‚Äá‚Äá‚Äá‚Äá‚Äá‚Äá‚ÄáLength', inline='vol2', group = vhGR)
vmaL = input.int(21, '', minval = 1, inline='vol2', group = vhGR, display = disp)
vhUC = input.color(color.new(#26a69a, 30), '‚ÄÉ‚ÄÉGrowing', inline='vol1', group = vhGR)
vhDC = input.color(color.new(#ef5350, 30), 'Falling', inline='vol1', group = vhGR)
vmaC = input.color(color.new(#2962ff, 0), 'Volume MA', inline='vol1', group = vhGR)
vhPL = input.string('Top', '‚ÄÉ‚ÄÉPlacement', options = ['Top', 'Bottom'], group = vhGR, display = disp)
vhLP = vhPL  == 'Top'
vhHT = 11 - input.int(8, '‚ÄÉ‚ÄÉHight' , minval = 1, maxval = 10, group = vhGR, display = disp)
vhVO = input.int(1, '‚ÄÉ‚ÄÉVertical Offset', minval = 0 , maxval = 20, group = vhGR, display = disp) / 20

cbGR = 'Volume Weighted Colored Bars'

cbTT = 'Colors bars based on the bar\'s volume relative to volume moving average\n' +
         ' - Bold bars when bar\'s volume is above volume moving average * upper threshold\n' +
         ' - Light bars when bar\'s volume is below volume moving average * lower threshold'

vwcb = input.bool(false, 'Volume Weighted Colored Bars', group = cbGR, tooltip = cbTT)
upTH = input.float(1.618, '‚ÄÉ‚ÄÉUpper Threshold', minval=1., step=.1, group = cbGR, display = disp)
dnTH = input.float(0.618, '‚ÄÉ‚ÄÉLower Threshold', minval=.1, step=.1, group = cbGR, display = disp)

//---------------------------------------------------------------------------------------------------------------------}
// EMA SETTINGS
//---------------------------------------------------------------------------------------------------------------------{
emaGR = 'Exponential Moving Averages'

ema1_length = input.int(20, 'EMA 1 Length', minval=1, group=emaGR)
ema1_color = input.color(color.red, 'EMA 1 Color', group=emaGR)

ema2_length = input.int(50, 'EMA 2 Length', minval=1, group=emaGR)
ema2_color = input.color(color.orange, 'EMA 2 Color', group=emaGR)

ema3_length = input.int(100, 'EMA 3 Length', minval=1, group=emaGR)
ema3_color = input.color(color.aqua, 'EMA 3 Color', group=emaGR)

ema4_length = input.int(200, 'EMA 4 Length', minval=1, group=emaGR)
ema4_color = input.color(color.blue, 'EMA 4 Color', group=emaGR)

//---------------------------------------------------------------------------------------------------------------------}
// IFVG UDT's
//---------------------------------------------------------------------------------------------------------------------{
type lab //Contains Necessary Label Data to Send to Label Function
    int x
    float y
    int dir

type fvg //Contains Necessary FVG Data to Send to Chart.
    int left = na
    float top = na
    int right = na
    float bot = na
    float mid = na
    int dir = na
    int state = na
    array<lab> labs = na
    int x_val = na

//---------------------------------------------------------------------------------------------------------------------}
// VP UDT's
//---------------------------------------------------------------------------------------------------------------------{
type bar
    float o = open
    float h = high
    float l = low
    float c = close
    float v = volume
    int   i = bar_index

type barData
    float [] bh
    float [] bl
    float [] bv
    bool  [] bp
    int   [] bn

type volData
    float [] vt
    float [] vb
    float [] vd

type tVP
    box         []  vp
    chart.point []  pPC
    polyline        dPC
    int             pcL
    int             laP
    int             lbP
    int             sI

type tVH
    line        []  vh
    chart.point []  pMA
    polyline        vMA

//---------------------------------------------------------------------------------------------------------------------}
// IFVG Functions
//---------------------------------------------------------------------------------------------------------------------{
//Basic Calcs
buffer = 100 //How many FVGs to keep in memory.
c_top = math.max(open,close)
c_bot = math.min(open,close)

label_maker(_x,_y,_dir) => //Used for making Labels
    switch
        _dir == 1 => label.new(_x,_y,"\n‚ñ≤", style = label.style_text_outline, color = invis,  textcolor = color.new(green,0), size = size.small, xloc = xloc.bar_time)
        _dir == -1 => label.new(_x,_y, "‚ñº\n", style = label.style_text_outline, color = invis,  textcolor = color.new(red,0), size = size.small, xloc = xloc.bar_time)

fvg_manage(_ary,_inv_ary) => //First step filtering of FVG data, Not all FVGs will be displayed, only inversions.
    if _ary.size() >= buffer
        _ary.shift()

    if _ary.size() > 0
        for i = _ary.size()-1 to 0
            value = _ary.get(i)
            _dir = value.dir

            if _dir == 1 and (c_bot < value.bot)
                value.x_val := time
                _inv_ary.push(_ary.remove(i))
            if _dir == -1 and (c_top > value.top)
                value.x_val := time
                _inv_ary.push(_ary.remove(i))

inv_manage(_ary) => //All inversions will be displayed.
    fire = false
    if _ary.size() >= buffer
        _ary.shift()
    if _ary.size() > 0
        for i = _ary.size()-1 to 0
            value = _ary.get(i)
            bx_top = value.top
            bx_bot = value.bot
            _dir = value.dir
            st = value.state

            if (st == 0 and _dir == 1)
                value.state := 1
                value.dir := -1
            if (_dir == -1 and st == 0)
                value.state := 1
                value.dir := 1
            if st >= 1
                value.right := time
            if (_dir == -1 and st == 1 and close < bx_bot and (wt?high:close[1]) >= bx_bot and (wt?high:close[1]) < bx_top)
                value.labs.push(lab.new(time,bx_top,-1))
                fire := true
            if (_dir == 1 and st == 1 and close > bx_top and (wt?low:close[1]) <= bx_top and (wt?low:close[1]) > bx_bot)
                value.labs.push(lab.new(time,bx_bot,1))
                fire := true
            if st >= 1 and ((_dir == -1 and c_top > bx_top) or (_dir == 1 and c_bot < bx_bot))
                _ary.remove(i)

    fire

send_it(_ary) => // Draws Everything on the Chart
    last_index = _ary.size()-1
    for [index,value] in _ary
        bx_top = value.top
        bx_bot = value.bot
        bx_left = value.left
        xval = value.x_val
        mid = value.mid
        col = value.dir == -1 ? green : red
        o_col = value.dir == -1 ? red : green

        if index > last_index - disp_num
            box.new(bx_left,bx_top,xval,bx_bot,bgcolor = col, border_color = invis, xloc = xloc.bar_time)
            box.new(xval,bx_top,time,bx_bot, bgcolor = o_col, border_color = invis, xloc = xloc.bar_time)

            line.new(bx_left,mid,time,mid, color = gray, style = line.style_dashed, xloc = xloc.bar_time)
            box.new(bar_index,bx_top,bar_index+50,bx_bot, bgcolor = o_col, border_color = invis)
            line.new(bar_index,mid,bar_index+50,mid, color = gray, style = line.style_dashed)

            for stuff in value.labs
                label_maker(stuff.x,stuff.y,stuff.dir)

//---------------------------------------------------------------------------------------------------------------------}
// VP Functions / Methods
//---------------------------------------------------------------------------------------------------------------------{

f_drawLineX(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width) =>
    var id = line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width)
    line.set_xy1(id, _x1, _y1)
    line.set_xy2(id, _x2, _y2)
    line.set_color(id, _color)

f_drawLabelX(_x, _y, _text, _color, _style, _textcolor, _size, _tooltip) =>
    var lb = label.new(_x, _y, _text, xloc.bar_index, yloc.price, _color, _style, _textcolor, _size, text.align_left, _tooltip)
    lb.set_xy(_x, _y)
    lb.set_text(_text)
    lb.set_tooltip(_tooltip)
    lb.set_textcolor(_textcolor)

getData(_ltf) => request.security_lower_tf(syminfo.tickerid, _ltf, bar.new(), ignore_invalid_timeframe = true)

f_gTF(_d) =>
    int tfInMs = timeframe.in_seconds(timeframe.period)
    int  mInMS = 60

    if _d == 2
        switch
            tfInMs <                 30  =>  '1S'
            tfInMs <          1 * mInMS  =>  '5S'
            tfInMs <=        15 * mInMS  =>   '1'
            tfInMs <=        60 * mInMS  =>   '5'
            tfInMs <=       240 * mInMS  =>  '15'
            tfInMs <=      1440 * mInMS  =>  '60'
            => 'D'

    else if _d == 1
        switch
            tfInMs <                 15  =>  '1S'
            tfInMs <                 30  =>  '5S'
            tfInMs <          1 * mInMS  => '15S'
            tfInMs <=         5 * mInMS  =>   '1'
            tfInMs <=        15 * mInMS  =>   '5'
            tfInMs <=        60 * mInMS  =>  '15'
            tfInMs <=       240 * mInMS  =>  '60'
            tfInMs <=      1440 * mInMS  => '240'
            => 'D'

f_gTS(_t) =>
    switch _t
        'Tiny'   => size.tiny
        'Small'  => size.small
        'Normal' => size.normal
        => size.auto

f_crossingLevelX(_price, _level) =>
    (_level > _price and _level < _price[1]) or (_level < _price and _level > _price[1])

alert_message(_message) =>
    alert(_message)

//---------------------------------------------------------------------------------------------------------------------}
// Variables
//---------------------------------------------------------------------------------------------------------------------{

// IFVG Variables
var bull_fvg_ary = array.new<fvg>(na) // FVG Data, Not all will be Drawn
var bear_fvg_ary = array.new<fvg>(na)

var bull_inv_ary = array.new<fvg>(na) // Inversion Data, All will be Drawn
var bear_inv_ary = array.new<fvg>(na)

// VP Variables
var barData bD = barData.new(
     array.new <float> (na),
     array.new <float> (na),
     array.new <float> (na),
     array.new <bool>  (na),
     array.new <int>   (na)
 )

volData vD = volData.new(
     array.new <float> (vpNR, 0.),
     array.new <float> (vpNR, 0.),
     array.new <float> (vpNR, 0.)
 )

var tVP VP = tVP.new(
     array.new<box>         (na),
     array.new<chart.point> (na),
     polyline.new           (na), na, na, na, na
 )

var tVH VH = tVH.new(
     array.new<line>        (na),
     array.new<chart.point> (na),
     polyline.new           (na)
 )

bar b = bar.new()
bar [] ltfBD = array.new<bar> (1, bar.new())

var float pHST = na
var float pLST = na
var string ltf = na

//---------------------------------------------------------------------------------------------------------------------}
// Delete drawings
//---------------------------------------------------------------------------------------------------------------------{
for boxes in box.all
    box.delete(boxes)

for lines in line.all
    line.delete(lines)

for labels in label.all
    label.delete(labels)

//---------------------------------------------------------------------------------------------------------------------}
// IFVG Detection
//---------------------------------------------------------------------------------------------------------------------{
atr = nz(ta.atr(200)*atr_multi, ta.cum(high - low) / (bar_index+1))

fvg_up = (low > high[2]) and (close[1] > high[2])
fvg_down = (high < low[2]) and (close[1] < low[2])

if fvg_up and math.abs(low-high[2]) > atr
    array.push(bull_fvg_ary,fvg.new(time[1], low, time, high[2], math.avg(low,high[2]), 1, 0,array.new<lab>(na),na))

if fvg_down and math.abs(low[2]-high) > atr
    array.push(bear_fvg_ary,fvg.new(time[1], low[2], time, high, math.avg(high,low[2]),-1 ,0,array.new<lab>(na),na))

//---------------------------------------------------------------------------------------------------------------------}
// VP Calculations
//---------------------------------------------------------------------------------------------------------------------{

nzV  = nz(b.v)
vSMA = ta.sma(nzV, vmaL)

rpS  = f_gTS(rpLS)
ppLS:= f_gTS(ppLS)

tPOS = lcDB == 'Top Right' ? position.top_right
     : lcDB == 'Middle Right' ? position.middle_right
     : position.bottom_left

if time == chart.left_visible_bar_time
    VP.sI := b.i

if vpRL
    vpLN := last_bar_index - VP.sI

if b.i == last_bar_index - vpLN
    VP.sI   := b.i
    pLST := b.l
    pHST := b.h
else if b.i > last_bar_index - vpLN
    pLST := math.min(b.l, pLST)
    pHST := math.max(b.h, pHST)

if vpLN <= 200
    ltf := f_gTF(2)
    ltfBD := getData(f_gTF(2))
else if vpLN <= 700
    ltf := f_gTF(1)
    ltfBD := getData(f_gTF(1))
else
    ltf := 'Chart'
    ltfBD := array.new<bar> (1, bar.new(b.o, b.h, b.l, b.c, b.v))

if barstate.ishistory and (b.i >= last_bar_index - vpLN) and b.i < last_bar_index and ltfBD.size() > 0

    if ltfBD.size() > 0 and not na(nz(ltfBD.get(0).v))
        for i = 0 to ltfBD.size() - 1
            bD.bh.push(ltfBD.get(i).h)
            bD.bl.push(ltfBD.get(i).l)
            bD.bv.push(ltfBD.get(i).v)

            if vsPT
                bD.bp.push(ltfBD.get(i).c > ltfBD.get(i).o)
            else
                bD.bp.push(ltfBD.get(i).c - ltfBD.get(i).l > ltfBD.get(i).h - ltfBD.get(i).c)

        bD.bn.push(ltfBD.size())

pSTP = (pHST - pLST) / vpNR

if barstate.islast and ltfBD.size() > 0

    if VP.vp.size() > 0
        for i = 0 to VP.vp.size() - 1
            box.delete(VP.vp.shift())

    if bD.bn.size() > vpLN
        qt = bD.bn.shift()
        for i = 0 to qt - 1
            bD.bh.shift()
            bD.bl.shift()
            bD.bv.shift()
            bD.bp.shift()

    VP.pPC.clear()
    VP.dPC.delete()

    if ltfBD.size() > 0 and not na(nz(ltfBD.get(0).v))
        for i = 0 to ltfBD.size() - 1
            bD.bh.push(ltfBD.get(i).h)
            bD.bl.push(ltfBD.get(i).l)
            bD.bv.push(ltfBD.get(i).v)

            if vsPT
                bD.bp.push(ltfBD.get(i).c > ltfBD.get(i).o)
            else
                bD.bp.push(ltfBD.get(i).c - ltfBD.get(i).l > ltfBD.get(i).h - ltfBD.get(i).c)

        bD.bn.push(ltfBD.size())

    bI  = math.min(vpLN, bar_index, 4999)
    bSZ = 0
    aSZ = bD.bv.size()

    for aI = 0 to aSZ - 1

        i = 0
        for pLL = pLST to pHST - pSTP by pSTP

            lH = bD.bh.get(aI)
            lL = bD.bl.get(aI)
            lV = bD.bv.get(aI)

            if lH >= pLL and lL < pLL + pSTP

                vPOR = if lL >= pLL and lH > pLL + pSTP
                    (pLL + pSTP - lL) / (lH - lL)
                else if lH <= pLL + pSTP and lL < pLL
                    (lH - pLL) / (lH - lL)
                else if lL >= pLL and lH <= pLL + pSTP
                    1
                else
                    0

                vD.vt.set(i, vD.vt.get(i) + lV * vPOR)

                if bD.bp.get(aI)
                    vD.vb.set(i, vD.vb.get(i) + lV * vPOR)
            i += 1

        if pcSH == 'Developing POC' and bI >= 0 and vpLN - bI >= 0 and vpLN - bI < bD.bn.size()
            if aI == bD.bn.get(vpLN - bI)
                VP.pPC.push(chart.point.new(b.i[bI], math.avg(b.h[bI], b.l[bI])))
                VP.pPC.push(chart.point.new(b.i[bI] + 1, pLST + (vD.vt.indexof(vD.vt.max()) + .5) * pSTP))
                bSZ += bD.bn.get(vpLN - bI)
                bI  -= 1
            else if aI == (bSZ + bD.bn.get(vpLN - bI)) and bSZ != 0
                VP.pPC.push(chart.point.new(b.i[bI] + 1, pLST + (vD.vt.indexof(vD.vt.max()) + .5) * pSTP))
                bSZ += bD.bn.get(vpLN - bI)
                bI  -= 1
            else if bI == 0
                VP.pPC.push(chart.point.new(b.i[bI] + 1, pLST + (vD.vt.indexof(vD.vt.max()) + .5) * pSTP))
                bSZ += bD.bn.get(vpLN - bI)

    VP.dPC := polyline.new(VP.pPC, false, false, xloc.bar_index, pocC, color(na), line.style_solid, pocW)

    for i = 0 to vpNR - 1
        bbp = 2 * vD.vb.get(i) - vD.vt.get(i)
        vD.vd.set(i, vD.vd.get(i) + bbp * (bbp > 0 ? 1 : -1) )

    VP.pcL := vD.vt.indexof(vD.vt.max())
    ttV     = vD.vt.sum() * vpVA
    va      = vD.vt.get(VP.pcL)
    VP.laP := VP.pcL
    VP.lbP := VP.pcL

    while va < ttV
        if VP.lbP == 0 and VP.laP == vpNR - 1
            break

        vaP = 0.
        if VP.laP < vpNR - 1
            vaP := vD.vt.get(VP.laP + 1)

        vbP = 0.
        if VP.lbP > 0
            vbP := vD.vt.get(VP.lbP - 1)

        if vaP >= vbP
            va  += vaP
            VP.laP += 1
        else
            va  += vbP
            VP.lbP -= 1

    vaH = pLST + (VP.laP + 1.) * pSTP
    poc = pLST + (VP.pcL + .5) * pSTP
    vaL = pLST + (VP.lbP + .0) * pSTP
    pLN = vpLN > 360 ? 360 : vpLN

    if vahS
        f_drawLineX(VP.sI, vaH, vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : spSH ? vpHO : 0) + last_bar_index : last_bar_index, vaH, xloc.bar_index, extend.none, vahC, line.style_solid, vahW)

    if pcSH == 'Last (Line)'
        f_drawLineX(VP.sI, poc, last_bar_index, poc, xloc.bar_index, extend.none, pocC, line.style_solid, pocW)

    if vlSH
        f_drawLineX(VP.sI, vaL, vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : spSH ? vpHO : 0) + last_bar_index : last_bar_index, vaL, xloc.bar_index, extend.none, valC, line.style_solid, valW)

    if vaBG
        VP.vp.push(box.new(VP.sI, vaL, last_bar_index, vaH, vBGC, 1, line.style_dotted, bgcolor = vBGC))

    if vpBG
        VP.vp.push(box.new(VP.sI, pLST, last_bar_index, pHST, bgC, 1, line.style_dotted, bgcolor = bgC))

    if vpLV
        f_drawLabelX(vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : spSH ? vpHO : 0) + last_bar_index : last_bar_index, pHST,
                     str.tostring(pHST, format.mintick), color.new(chart.fg_color, 89), vpRT ? not vpSH and not spSH ? label.style_label_left : label.style_label_down : label.style_label_left, chart.fg_color, rpS,
                     'Profile High')

        f_drawLabelX(vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : spSH ? vpHO : 0) + last_bar_index + (spSH ? int(vD.vd.max() / vD.vt.max() * pLN * vpWD) : 0) : last_bar_index, vaH,
                     str.tostring(vaH, format.mintick), color.new(vahC, 89), label.style_label_left, vahC, rpS, 'Value Area High')

        f_drawLabelX(vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : spSH ? vpHO : 0) + last_bar_index + (spSH ? int(vD.vd.max() / vD.vt.max() * pLN * vpWD) : 0) : last_bar_index, poc,
                     str.tostring(poc, format.mintick), color.new(pocC, 89), label.style_label_left, pocC, rpS, 'Point of Control')

        f_drawLabelX(vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : spSH ? vpHO : 0) + last_bar_index + (spSH ? int(vD.vd.max() / vD.vt.max() * pLN * vpWD) : 0) : last_bar_index, vaL,
                     str.tostring(vaL, format.mintick), color.new(valC, 89), label.style_label_left, valC, rpS, 'Value Area Low')

        f_drawLabelX(vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : spSH ? vpHO : 0) + last_bar_index : last_bar_index, pLST,
                     str.tostring(pLST, format.mintick), color.new(chart.fg_color, 89), vpRT ? not vpSH and not spSH ? label.style_label_left : label.style_label_up : label.style_label_left, chart.fg_color, rpS,
                     'Profile Low')

    if vpST
        table change = table.new(tPOS, 2, 10, border_width = 3)
        tC = chart.fg_color
        table.cell(change, 0, 0, 'Profile High', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS,
                     tooltip = 'profile high - ' + str.tostring(pHST, format.mintick) + '\n %' + str.tostring((pHST - pLST) / pLST * 100, '#.##') + ' higher than the profile low (' + str.tostring(pLST, format.mintick) + ')')
        table.cell(change, 1, 0, str.tostring(pHST, format.mintick), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 1, 'Value Area High', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS)
        table.cell(change, 1, 1, str.tostring(vaH, format.mintick), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 2, 'Point of Control', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS)
        table.cell(change, 1, 2, str.tostring(poc, format.mintick), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 3, 'Value Area Low', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS)
        table.cell(change, 1, 3, str.tostring(vaL, format.mintick), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 4, 'Profile Low', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS,
                     tooltip = 'profile low - '  + str.tostring(pLST, format.mintick) + '\n %' + str.tostring((pHST - pLST) / pHST * 100, '#.##') + ' lower than the profile high (' + str.tostring(pHST, format.mintick) + ')')
        table.cell(change, 1, 4, str.tostring(pLST, format.mintick), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 5, 'Total Volume\nin VP Range', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS, tooltip = 'total traded volume in vp range')
        table.cell(change, 1, 5, str.tostring(vD.vt.sum(), format.volume), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 6, 'Avg Volume/Bar', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS, tooltip = 'average traded volume per bar in vp range')
        table.cell(change, 1, 6, str.tostring(vD.vt.sum() / (vpLN + 1), format.volume), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 7, 'Volume MA (' + str.tostring(vmaL) + ')', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS, tooltip = 'volume moving average')
        table.cell(change, 1, 7, str.tostring(vSMA, format.volume), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 8, 'Number of Bars', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS, tooltip = 'number of chart bars : ' + str.tostring(vpLN) + ' + 1 (developping bar)')
        table.cell(change, 1, 8, str.tostring(vpLN + 1), text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)
        table.cell(change, 0, 9, 'Data From', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_left, text_size = ppLS,
                     tooltip = 'volume data fetching logic\n\nif #bars <= 200\n -two lower timeframes\nelse if #bars <= 700\n -one lower timeframe\nelse\n -chart timeframe')
        table.cell(change, 1, 9, ltf + ' TF', text_color = tC, bgcolor = color.new(tC, 80), text_halign = text.align_right, text_size = ppLS)

    for i = 0 to vpNR - 1

        if vpSH
            sBI = vpRT ? int((pLN * vpWD + vpHO)) + int(last_bar_index - vD.vb.get(i) / vD.vt.max() * pLN * vpWD) : VP.sI
            eBI = vpRT ? int((pLN * vpWD + vpHO)) + last_bar_index : int(sBI + vD.vb.get(i) / vD.vt.max() * pLN * vpWD)
            VP.vp.push(box.new(sBI, pLST + (i + .1) * pSTP, eBI, pLST + (i + .9) * pSTP, color(na), bgcolor = i >= VP.lbP and i <= VP.laP ? vaUC : vpUC))

            sBI := vpRT ? sBI : eBI
            eBI := vpRT ? sBI - int( (vD.vt.get(i) - vD.vb.get(i)) / vD.vt.max() * pLN * vpWD) : sBI + int( (vD.vt.get(i) - vD.vb.get(i)) / vD.vt.max() * pLN * vpWD)
            VP.vp.push(box.new(sBI, pLST + (i + .1) * pSTP, eBI, pLST + (i + .9) * pSTP, color(na), bgcolor = i >= VP.lbP and i <= VP.laP ? vaDC : vpDC))

        if spSH
            sBI = vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : vpHO) + int(last_bar_index + vD.vd.get(i) / vD.vt.max() * pLN * vpWD) : VP.sI
            eBI = vpRT ? (vpSH ? int((pLN * vpWD + vpHO)) : vpHO) + last_bar_index : vpRL ? int(sBI + vD.vd.get(i) / vD.vt.max() * pLN * vpWD) : int(sBI - vD.vd.get(i) / vD.vt.max() * pLN * vpWD)

            bbp = 2 * vD.vb.get(i) - vD.vt.get(i)
            VP.vp.push(box.new(sBI, pLST + (i + .1) * pSTP, eBI, pLST + (i + .9) * pSTP, color(na), bgcolor = bbp > 0 ? spUC : spDC))

        if sdSH and vD.vt.get(i) / vD.vt.max() < sdTH
            sdC = pLST + (i + 0.50) * pSTP > pLST + (VP.pcL + .5) * pSTP ? sdSC : sdDC
            VP.vp.push(box.new(b.i[math.min(vpLN, bar_index, 4999)], pLST + (i + 1.) * pSTP, b.i, pLST + (i + .0) * pSTP, color(na), bgcolor = sdC ))

//---------------------------------------------------------------------------------------------------------------------}
// Volume Histogram Calculations
//---------------------------------------------------------------------------------------------------------------------{

pHSTv = ta.highest(b.h, math.min(vpLN < 497 ? vpLN : 496, bar_index + 1))
pLSTv = ta.lowest (b.l, math.min(vpLN < 497 ? vpLN : 496, bar_index + 1))
vHST  = ta.highest(nzV, math.min(vpLN < 497 ? vpLN : 496, bar_index + 1))
vMAR  = nzV / vSMA

if barstate.islast and not na(nzV) and vhSH and vSMA > 0

    pCHR = (pHSTv - pLSTv) / pHSTv

    if VH.vh.size() > 0
        for i = 0 to VH.vh.size() - 1
            line.delete(VH.vh.shift())

    VH.pMA.clear()
    VH.vMA.delete()

    for bI = 0 to math.min(vpLN, bar_index, 4999)

        if VH.vh.size() < 500
            VH.vh.push(line.new(
                 b.i[bI],  vhLP ? pHST + pHSTv * pCHR * vhVO : pLST - pLSTv * pCHR * vhVO,
                 b.i[bI], (vhLP ? pHST + pHSTv * pCHR * vhVO : pLST - pLSTv * pCHR * vhVO) * (1 + ( vhLP ? 1 : -1) * nzV[bI] / vHST * pCHR / vhHT),
                 xloc.bar_index, extend.none, vhUC, line.style_solid, 1))

            if vmaS and not na(vSMA[bI])
                VH.pMA.push(chart.point.new(b.i[bI], vhLP ? pHST + pHSTv * pCHR * vhVO : pLST - pLSTv * pCHR * vhVO))

    VH.vMA := polyline.new(VH.pMA, false, false, xloc.bar_index, vmaC, color(na), line.style_solid, 1)

//---------------------------------------------------------------------------------------------------------------------}
// Volume Weighted Colored Bars
//---------------------------------------------------------------------------------------------------------------------{

barcolor(vwcb and not na(nzV) ? nzV > vSMA * upTH ? b.o < b.c ? #006400 : #910000 : nzV < vSMA * dnTH ? b.o < b.c ? #7FFFD4 : #FF9800 : na : na, title='Volume Weighted Colored Bars', editable = false)

//---------------------------------------------------------------------------------------------------------------------}
// Running Functions
//---------------------------------------------------------------------------------------------------------------------{
// FVG_Data -> Inversion_Data -> Chart
fvg_manage(bull_fvg_ary,bull_inv_ary)
fvg_manage(bear_fvg_ary,bear_inv_ary)

bear_signal = inv_manage(bull_inv_ary)
bull_signal = inv_manage(bear_inv_ary)

if barstate.islast
    send_it(bull_inv_ary)
    send_it(bear_inv_ary)

//---------------------------------------------------------------------------------------------------------------------}
// EMAs Calculations
//---------------------------------------------------------------------------------------------------------------------{
shortest = ta.ema(close, ema1_length)
short = ta.ema(close, ema2_length)
longer = ta.ema(close, ema3_length)
longest = ta.ema(close, ema4_length)

plot(shortest, color=ema1_color, title="EMA 1")
plot(short, color=ema2_color, title="EMA 2")
plot(longer, color=ema3_color, title="EMA 3")
plot(longest, color=ema4_color, title="EMA 4")

//---------------------------------------------------------------------------------------------------------------------}
// Detecci√≥n de Se√±ales Adicionales
//---------------------------------------------------------------------------------------------------------------------{

// Obtener tama√±o de se√±al
sigSize = emaSignalSize == "Tiny" ? size.tiny : emaSignalSize == "Small" ? size.small : size.normal

// Se√±ales de Cruce de EMAs
emaFast = ta.ema(close, emaCrossFast)
emaSlow = ta.ema(close, emaCrossSlow)
emaBullCross = ta.crossover(emaFast, emaSlow)
emaBearCross = ta.crossunder(emaFast, emaSlow)

if enableEMACross and emaBullCross
    label.new(bar_index, low, "‚¨Ü\nEMA", style = label.style_label_up, 
        color = color.new(signalBullColor, 80), textcolor = signalBullColor, size = sigSize,
        tooltip = "EMA " + str.tostring(emaCrossFast) + " cruz√≥ por encima de EMA " + str.tostring(emaCrossSlow))

if enableEMACross and emaBearCross
    label.new(bar_index, high, "EMA\n‚¨á", style = label.style_label_down, 
        color = color.new(signalBearColor, 80), textcolor = signalBearColor, size = sigSize,
        tooltip = "EMA " + str.tostring(emaCrossFast) + " cruz√≥ por debajo de EMA " + str.tostring(emaCrossSlow))

// Se√±ales de Niveles del Perfil de Volumen
var float lastPOC = na
var float lastVAH = na
var float lastVAL = na

if barstate.islast
    lastPOC := pLST + (VP.pcL + .50) * pSTP
    lastVAH := pLST + (VP.laP + 1.00) * pSTP
    lastVAL := pLST + (VP.lbP + 0.00) * pSTP

// Se√±ales de Toque del POC
pocTouchBull = enableVPSignals and vpSignalPOC and not na(lastPOC) and close > lastPOC and low <= lastPOC and close[1] < lastPOC
pocTouchBear = enableVPSignals and vpSignalPOC and not na(lastPOC) and close < lastPOC and high >= lastPOC and close[1] > lastPOC

if pocTouchBull
    label.new(bar_index, low, "‚¨Ü\nPOC", style = label.style_label_up, 
        color = color.new(signalBullColor, 80), textcolor = signalBullColor, size = sigSize,
        tooltip = "Precio cruz√≥ por encima del POC: " + str.tostring(lastPOC, format.mintick))

if pocTouchBear
    label.new(bar_index, high, "POC\n‚¨á", style = label.style_label_down, 
        color = color.new(signalBearColor, 80), textcolor = signalBearColor, size = sigSize,
        tooltip = "Precio cruz√≥ por debajo del POC: " + str.tostring(lastPOC, format.mintick))

// Se√±ales de Toque del VAH
vahTouchBear = enableVPSignals and vpSignalVAH and not na(lastVAH) and high >= lastVAH and close < lastVAH and high[1] < lastVAH

if vahTouchBear
    label.new(bar_index, high, "VAH\n‚¨á", style = label.style_label_down, 
        color = color.new(signalBearColor, 80), textcolor = signalBearColor, size = sigSize,
        tooltip = "Precio rechazado en VAH: " + str.tostring(lastVAH, format.mintick))

// Se√±ales de Toque del VAL
valTouchBull = enableVPSignals and vpSignalVAL and not na(lastVAL) and low <= lastVAL and close > lastVAL and low[1] > lastVAL

if valTouchBull
    label.new(bar_index, low, "‚¨Ü\nVAL", style = label.style_label_up, 
        color = color.new(signalBullColor, 80), textcolor = signalBullColor, size = sigSize,
        tooltip = "Precio rebot√≥ desde VAL: " + str.tostring(lastVAL, format.mintick))

// Se√±ales de Zonas de Oferta/Demanda
if enableSDSignals and sdSH
    for i = 0 to vpNR - 1
        if vD.vt.get(i) / vD.vt.max() < sdTH
            zonePrice = pLST + (i + 0.5) * pSTP
            isSupply = zonePrice > lastPOC
            
            // Verificar si el precio entra en la zona
            if isSupply and high >= zonePrice and high[1] < zonePrice
                if sdSignalStrength == "All" or close < open
                    label.new(bar_index, high, "OFERTA\n‚¨á", style = label.style_label_down, 
                        color = color.new(signalBearColor, 80), textcolor = signalBearColor, size = sigSize,
                        tooltip = "Precio entr√≥ en Zona de Oferta en " + str.tostring(zonePrice, format.mintick))
                    break
            
            else if not isSupply and low <= zonePrice and low[1] > zonePrice
                if sdSignalStrength == "All" or close > open
                    label.new(bar_index, low, "‚¨Ü\nDEMANDA", style = label.style_label_up, 
                        color = color.new(signalBullColor, 80), textcolor = signalBullColor, size = sigSize,
                        tooltip = "Precio entr√≥ en Zona de Demanda en " + str.tostring(zonePrice, format.mintick))
                    break

// Se√±ales de Picos de Volumen
volSpike = enableVolSignals and nzV > vSMA * volSpikeMulti

if volSpike
    isVolBull = close > open
    if isVolBull
        label.new(bar_index, low, "‚¨Ü\nVOL", style = label.style_label_up, 
            color = color.new(signalBullColor, 80), textcolor = signalBullColor, size = sigSize,
            tooltip = "Volumen Alto: " + str.tostring(nzV, format.volume) + "\nPromedio: " + str.tostring(vSMA, format.volume))
    else
        label.new(bar_index, high, "VOL\n‚¨á", style = label.style_label_down, 
            color = color.new(signalBearColor, 80), textcolor = signalBearColor, size = sigSize,
            tooltip = "Volumen Alto: " + str.tostring(nzV, format.volume) + "\nPromedio: " + str.tostring(vSMA, format.volume))

//---------------------------------------------------------------------------------------------------------------------}
// Opciones de Alertas
//---------------------------------------------------------------------------------------------------------------------{
alertcondition(bull_signal, "Se√±al Alcista IFVG", "Se√±al Alcista IFVG en {{ticker}}")
alertcondition(bear_signal, "Se√±al Bajista IFVG", "Se√±al Bajista IFVG en {{ticker}}")

if emaBullCross
    alert("EMA " + str.tostring(emaCrossFast) + " cruz√≥ por encima de EMA " + str.tostring(emaCrossSlow) + " en {{ticker}}")
if emaBearCross
    alert("EMA " + str.tostring(emaCrossFast) + " cruz√≥ por debajo de EMA " + str.tostring(emaCrossSlow) + " en {{ticker}}")

alertcondition(pocTouchBull, "Toque Alcista POC", "Precio cruz√≥ por encima del POC en {{ticker}}")
alertcondition(pocTouchBear, "Toque Bajista POC", "Precio cruz√≥ por debajo del POC en {{ticker}}")

alertcondition(vahTouchBear, "Rechazo Bajista VAH", "Precio rechazado en VAH en {{ticker}}")
alertcondition(valTouchBull, "Rebote Alcista VAL", "Precio rebot√≥ desde VAL en {{ticker}}")

alertcondition(volSpike, "Pico de Volumen", "Volumen alto detectado en {{ticker}}")

if f_crossingLevelX(close[1], pLST + (VP.pcL + .50) * pSTP) and pcSH != 'None'
    alert('price action ' + (close[1] > pLST + (VP.pcL + .50) * pSTP ? 'crossed above ' : 'crossed below ') + 'the point of control line')

if f_crossingLevelX(close[1], pLST + (VP.laP + 1.00) * pSTP) and vahS
    alert('price action ' + (close[1] > pLST + (VP.laP + 1.00) * pSTP ? 'crossed above ' : 'crossed below ') + 'the value area high line')

if f_crossingLevelX(close[1], pLST + (VP.lbP + 0.00) * pSTP) and vlSH
    alert('price action ' + (close[1] > pLST + (VP.lbP + 0.00) * pSTP ? 'crossed above ' : 'crossed below ') + 'the value area low line')

if nzV > vSMA * upTH and (vwcb or vhSH)
    alert('high volume detected')

if nzV > vSMA * 4.669 and (vwcb or vhSH)
    alert('watch out volume spike detected, may be a sign of exhaustion')
